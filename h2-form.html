<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="./behaviors/ajax-behavior.html">
<link rel="import" href="./behaviors/base-behavior.html">
<link rel="import" href="h2-widget.html">
<dom-module id="h2-form">
    <template>
        <style id="localStyle">

            dom-repeat {
                display: none;
            }

            dom-if {
                display: none;
            }

            .btns {
                position: relative;
                padding: 8px 8px 8px 24px;
                margin: 0;
                display: flex;
                justify-content: flex-end;
            }

            .container {
                display: grid;
                grid-template-columns: 30% 30% auto;
                grid-column-gap: 10px;
            }

            .container__item:only-of-type {
                grid-column: 1 / end;
            }

        </style>
        <h2>[[metadata.title]]</h2>

        <div class="container">
            <template is="dom-repeat" items="[[ metadata.fields ]]" as="fieldMeta" filter="filterVisible">
                <h2-widget
                        class="container__item"
                        id="[[ getEditorId(fieldMeta.name) ]]"
                        editable
                        context="{{ context }}"
                        value="[[ getValueByKey(context,fieldMeta.name) ]]"
                        on-value-changed="onValueChange"
                        on-widget-attached="onWidgetAttached"
                        metadata="[[ fieldMeta ]]">
                </h2-widget>
            </template>
        </div>

        <div class="btns">
            <template is="dom-if" if="[[ !metadata.isSubmitForbidden ]]">
                <paper-button raised on-click="submit">保存</paper-button>
            </template>
            <paper-button raised dialog-dismiss>关闭</paper-button>
        </div>
    </template>
    <script>
      class H2Form extends Polymer.mixinBehaviors([BaseBehavior, AjaxBehavior], Polymer.Element) {

        static get is() {
          return "h2-form";
        }

        static get properties() {
          return {
            _subscriptionTable: {
              type: Object,
              value: function () {
                return {};
              }
            },
            context: {
              type: Object,
              notify: true,
              observable: true,
              value: function () {
                return {};
              }
            },
            metadata: {
              type: Object,
              observer: '__metadataChange'
            },
            onSubmit: {
              type: Object
            },
            onError: {
              type: Object
            },
            onSuccess: {
              type: Object
            }
          }
        }

        __updateStyle({style}) {
          if (!style) return;

          let styleEle = this.shadowRoot.querySelector('style#customStyle');

          if (!styleEle) {
            styleEle = document.createElement('style');
            styleEle.id = 'customStyle';
            styleEle.setAttribute('scope', this.constructor.is);
            this.shadowRoot.appendChild(styleEle);
          }

          styleEle.appendChild(document.createTextNode(style));
        }

        __metadataChange(metadata) {
          if (metadata) {
            return this.__updateStyle(metadata);
          }
        }

        watch(watchFields, callback) {
          if (Function.prototype.isPrototypeOf(callback)) {
            for (let field of watchFields) {
              this._subscriptionTable[field] = this._subscriptionTable[field] || [];
              this._subscriptionTable[field].push(callback);
            }

            setTimeout(() => callback(this.context), 0);

          } else {
            console.warn(`Oops, ${callback} is not a function`);
          }
        }

        onWidgetAttached(e) {
          const fieldMeta = e.model.fieldMeta;
          fieldMeta.onAttached && fieldMeta.onAttached.call(this, e.target);
        }

        onValueChange(e) {

          const {name: myFieldName} = e.model.fieldMeta;

          // Nothing depends on me！
          if (!this._subscriptionTable[myFieldName]) return;

          this._subscriptionTable[myFieldName].forEach(fn => {
            fn(this.context);
          });
        }

        getEditorId(fieldName) {
          return `${this.constructor.is}-${fieldName}-editor`;
        }

        submit() {

          if (!this._validate()) return;

          if (this.isFunction(this.onSubmit)) {
            return this.onSubmit(this._requestBody());
          }

          const _submit = () => {
            this.post({
              url: this.metadata.formUrl,
              sendAsJson: this.metadata.sendAsJson,

              data: this._requestBody()
            }, (data) => {

              this.dispatchEvent(new CustomEvent("h2-form-submitted", {
                bubbles: true, composed: true, detail: data
              }));

              this.isFunction(this.onSuccess) && this.onSuccess(data);

            }, (err) => this.isFunction(this.onError) && this.onError(err));

          };

          if (this.metadata.confirm) {
            if (window.confirm(this.metadata.confirm)) {
              _submit();
            }
          } else {
            _submit();
          }
        }

        filterVisible(item) {
          return !!item.visible;
        }

        _getEditor(fieldName) {
          return this.root.querySelector(`#${this.getEditorId(fieldName)}`);
        }

        _validate() {
          // return true if there's no field
          if (!this.metadata.fields || this.metadata.fields.length == 0) return true;

          return this.metadata.fields
              .filter(fieldMeta => fieldMeta.visible && (fieldMeta.required || !!fieldMeta.validate))
              .every(fieldMeta => {
                const editor = this._getEditor(fieldMeta.name);
                // if the editor does not have a validator,return true
                return editor.validate ? editor.validate() : true;
              });
        }

        _requestBody() {
          let requestBody = {};
          this.metadata.fields
              .forEach(fieldMeta => {
                requestBody[fieldMeta.alias || fieldMeta.name] = this.context[fieldMeta.name]
              });

          // Execute the hook before submit.
          if (this.metadata.beforeSubmit) {
            requestBody = this.metadata.beforeSubmit(requestBody);
          }

          return requestBody;
        }
      }

      customElements.define(H2Form.is, H2Form);
    </script>
</dom-module>